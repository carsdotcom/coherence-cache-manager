package com.cars.cache.coherence;

import java.lang.reflect.Field;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cache.Cache;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.cache.support.SimpleValueWrapper;
import org.springframework.util.Assert;

import com.tangosol.net.NamedCache;

/**
 * {@link Cache} implementation using Coherence {@link NamedCache}.<br>
 * <br>
 * <u>Usage</u> <br>
 * <br>
 * 1) This implementation does not allow null values in the cache.<br>
 * <br>
 * 2) {@link Cacheable} on a non-arg method will result in a serialization error
 * when using Coherence Pof configuration. This is because the default key
 * generated by Spring cache abstraction is not registered with the Coherence
 * serialization scheme. <br>
 * <br>
 * 3) {@link Cacheable} on a method returning a collection is not recommended.
 * Use {@link CachePut} instead. The implementation will look into key mappings
 * from {@link CoherenceConfig} to resolve a key for each entry in the
 * collection return type.
 * @author dmistry
 * 
 */
public class CoherenceCache implements Cache {

	private Logger logger = LoggerFactory.getLogger(CoherenceCache.class);

	private final NamedCache cache;

	private String keyName;

	private boolean cacheAll = false;

	private int bufferSize;

	public CoherenceCache(NamedCache namedCache, int bufferSize) {
		Assert.notNull(namedCache, "NamedCache must not be null");
		Assert.isTrue(namedCache.isActive(),
				"An active NamedCache is required - current NamedCache["
						+ namedCache.getCacheName() + "] is not active");
		this.cache = namedCache;
		this.bufferSize = bufferSize;
	}

	public CoherenceCache(NamedCache namedCache, int bufferSize,
			String keyName, boolean cacheAll) {
		Assert.notNull(namedCache, "NamedCache must not be null");
		Assert.isTrue(namedCache.isActive(),
				"An active NamedCache is required - current NamedCache["
						+ namedCache.getCacheName() + "] is not active");
		if (cacheAll) {
			Assert.hasLength(keyName,
					"Key name is required to resolve cache keys");
		}
		this.cache = namedCache;
		this.keyName = keyName;
		this.cacheAll = cacheAll;
		this.bufferSize = bufferSize;
	}

	@Override
	public final String getName() {
		return this.cache.getCacheName();
	}

	@Override
	public final NamedCache getNativeCache() {
		return this.cache;
	}

	@Override
	public ValueWrapper get(Object key) {
		if (logger.isDebugEnabled()) {
			logger.debug("Getting value for key [" + key + "] from cache");
		}
		Object value = this.cache.get(key);
		return (value != null ? new SimpleValueWrapper(value) : null);
	}

	@Override
	@SuppressWarnings("unchecked")
	public <T> T get(Object key, Class<T> type) {
		if (logger.isDebugEnabled()) {
			logger.debug("Getting " + type.getClass().getName() + " with key ["
					+ key + "] from cache");
		}
		Object value = this.cache.get(key);
		if (type != null && !type.isInstance(value)) {
			throw new IllegalStateException(
					"Cached value is not of required type [" + type.getName()
							+ "]: " + value);
		}
		return (T) value;
	}

	@Override
	public void put(Object key, Object value) {
		if (value != null) {
			if (logger.isDebugEnabled()) {
				logger.debug("Putting " + value.getClass().getName()
						+ " with key [" + key + "] in cache");
			}
			if (this.cacheAll) {
				if (value instanceof Collection<?>) {
					Collection<?> entries = (Collection<?>) value;
					putAllInCoherence(entries);
				}
				else {
					this.cache.putAll(Collections.singletonMap(key, value));
				}
			}
			else {
				this.cache.putAll(Collections.singletonMap(key, value));
			}
		}
	}

	private void putAllInCoherence(Collection<?> entries) {
		Map<Object, Object> toCache = new HashMap<>();
		int count = 0;
		for (Object entry : entries) {
			try {
				Field field = entry.getClass().getDeclaredField(this.keyName);
				field.setAccessible(true);
				toCache.put(field.get(entry), entry);
				if ((count++ % bufferSize) == 0) {
					this.cache.putAll(toCache);
					toCache.clear();
				}
			}
			catch (NoSuchFieldException | SecurityException
					| IllegalArgumentException | IllegalAccessException e) {
				throw new IllegalArgumentException(
						"Unable to resolve key for ["
								+ entry.getClass().getName() + "]", e);
			}
		}
		if (!toCache.isEmpty()) {
			this.cache.putAll(toCache);
		}
	}

	@Override
	public void evict(Object key) {
		this.cache.remove(key);
	}

	@Override
	public void clear() {
		this.cache.clear();
	}
}
